ğŸ§  NAJPIERW OBRAZ CAÅOÅšCI 
WyobraÅº sobie serwer jako recepcjÄ™ w hotelu:
klient = przeglÄ…darka (Chrome, curl)
serwer = TwÃ³j program
socket = drzwi wejÅ›ciowe
HTTP request = formularz, ktÃ³ry klient skÅ‚ada
HTTP response = odpowiedÅº recepcji
poll/select = ochrona, ktÃ³ra patrzy kto czeka
event loop = recepcjonistka, ktÃ³ra caÅ‚y czas krÄ…Å¼y
Teraz rozbijemy to na osoby.

ğŸ‘¤ OSOBA 1 â€“ CORE / NETWORK

Fundament. Bez tego NIC nie dziaÅ‚a.
Ta osoba nie zajmuje siÄ™ HTTP.
Ona robi komunikacjÄ™ miÄ™dzy komputerami.

ğŸ”Œ SOCKET â€“ co to jest?
Socket = poÅ‚Ä…czenie sieciowe

To jest:
kanaÅ‚ komunikacji miÄ™dzy:
klientem (np. Chrome)
a serwerem (TwÃ³j program)

W C++:
socket to liczba (int) â†’ tzw. file descriptor

Proces:
serwer tworzy socket
mÃ³wi: â€sÅ‚ucham na porcie 8080â€
klient siÄ™ Å‚Ä…czy
powstaje socket klienta
przez socket lecÄ… dane (request / response)
ğŸ‘‰ Bez socketÃ³w nie ma Internetu

ğŸ‘‚ LISTEN / ACCEPT â€“ co siÄ™ dzieje?
listen() â†’ â€czekam na klientÃ³wâ€
accept() â†’ â€ktoÅ› przyszedÅ‚ â€“ wpuszczam goâ€
KaÅ¼dy klient dostaje swÃ³j socket.

ğŸš¦ NON-BLOCKING â€“ co to znaczy?
Non-blocking = nigdy nie czekaj
Normalnie:

read() moÅ¼e czekaÄ‡ â†’ PROGRAM STOI âŒ
Non-blocking:
jeÅ›li nie ma danych â†’ wraca od razu
serwer moÅ¼e obsÅ‚uÅ¼yÄ‡ innych klientÃ³w
ğŸ‘‰ To jest absolutny wymÃ³g projektu.

ğŸ‘€ POLL / SELECT â€“ po co to?
Masz:
50 klientÃ³w
kaÅ¼dy moÅ¼e coÅ› wysÅ‚aÄ‡
albo czekaÄ‡

Nie moÅ¼esz:
pytaÄ‡ kaÅ¼dego co chwilÄ™ (za wolne)
blokowaÄ‡ siÄ™ na jednym
poll/select mÃ³wi Ci:

â€Hej, klient nr 7 ma dane do odczytuâ€
â€Klient nr 12 jest gotowy do zapisuâ€
ğŸ‘‰ Bez poll = fail projektu

ğŸ” EVENT LOOP â€“ serce serwera
To jest pÄ™tla nieskoÅ„czona:
while (server dziaÅ‚a):
    poll()
    jeÅ›li nowy klient â†’ accept
    jeÅ›li klient wysyÅ‚a â†’ read
    jeÅ›li klient czeka na odpowiedÅº â†’ write
To dziaÅ‚a ciÄ…gle, aÅ¼ wyÅ‚Ä…czysz serwer.
ğŸ‘‰ Event loop = serce + mÃ³zg
ğŸ§â€â™‚ï¸ ZARZÄ„DZANIE KLIENTAMI

Serwer musi:
pamiÄ™taÄ‡ klientÃ³w
wiedzieÄ‡:
kto juÅ¼ wysÅ‚aÅ‚ request
kto czeka na odpowiedÅº
kto siÄ™ rozÅ‚Ä…czyÅ‚

NajczÄ™Å›ciej:
mapa fd â†’ Client

ğŸ›¡ STABILNOÅšÄ†
To znaczy:
klient siÄ™ rozÅ‚Ä…czyÅ‚ â†’ serwer Å¼yje
request niepeÅ‚ny â†’ serwer Å¼yje
bÅ‚Ä…d â†’ serwer Å¼yje
ğŸ‘‰ Crash = 0 punktÃ³w

ğŸ‘¤ OSOBA 2 â€“ HTTP + CONFIG
Ta osoba nadaje sens danym

ğŸ“© HTTP REQUEST â€“ co to?
To jest tekst, np.:
GET /index.html HTTP/1.1
Host: localhost
Content-Length: 0

Parser HTTP:
czyta tekst
rozbija na:
metodÄ™ (GET)
Å›cieÅ¼kÄ™ (/index.html)
nagÅ‚Ã³wki
body

ğŸ“¤ HTTP RESPONSE â€“ co to?
OdpowiedÅº serwera:
HTTP/1.1 200 OK
Content-Length: 5
Hello
Response builder:
ustala status
ustala nagÅ‚Ã³wki
dokÅ‚ada body

ğŸ”¢ STATUS CODES â€“ co to?
200 OK
404 Not Found
403 Forbidden
405 Method Not Allowed
500 Internal Server Error
ğŸ‘‰ ZÅ‚e statusy = fail

âš™ï¸ CONFIG â€“ po co?
Config mÃ³wi serwerowi:
na jakim porcie
gdzie sÄ… pliki
jakie metody dozwolone
gdzie CGI
limit body
Bez configu serwer byÅ‚by â€na sztywnoâ€.

ğŸ§­ ROUTING â€“ co to?
Decyzja:
â€Ten request â†’ do tego katalogu / CGI / plikuâ€
Np:
/ â†’ /var/www
/upload â†’ upload folder
/php â†’ CGI

ğŸš¨ ERROR PAGES
JeÅ›li coÅ› pÃ³jdzie Åºle:
serwer zawsze musi odpowiedzieÄ‡
nawet jeÅ›li pliku nie ma

ğŸ‘¤ OSOBA 3 â€“ CGI + FILES
PoÅ‚Ä…czenie serwera z systemem

ğŸ“ STATIC FILES
Serwowanie plikÃ³w:
HTML
CSS
JPG
GET â†’ plik â†’ response

ğŸ“¤ UPLOAD
POST:
klient wysyÅ‚a plik
serwer zapisuje go na dysku

âŒ DELETE
usuwa plik
sprawdza uprawnienia

ğŸ§ª CGI â€“ co to w ogÃ³le jest?
CGI = uruchamiasz inny program
Serwer:
dostaje request
odpala program
daje mu dane
czyta wynik
wysyÅ‚a klientowi

ğŸ”€ PIPE / FORK / ENV
fork() â†’ tworzysz proces dziecka
pipe() â†’ rura do komunikacji
env â†’ zmienne Å›rodowiskowe (REQUEST_METHOD itd.)
ğŸ‘‰ To jest najtrudniejsza czÄ™Å›Ä‡ projektu.

